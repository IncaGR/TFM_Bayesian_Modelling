typeof(summary(fit)$summary)
tidyMCMC(fit)
df = tidyMCMC(fit)
df %>% filter(!grepl("^b0|sigma_y|lp_",df$term))
df %>% filter(!grepl("^b0|sigma_y|lp_",df$term)) %>% nrow()
df = tidyMCMC(fit)
k = df %>% filter(!grepl("^b0|sigma_y|lp_",df$term)) %>% nrow()
POOLED = TRUE
if(POOLED){
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_pooled.RDS")
df = tidyMCMC(fit)
k = df %>% filter(!grepl("^b0|sigma_y|lp_",df$term)) %>% nrow()
sims <- rstan::extract(fit)
y_pred = mean(sims$b0) +
mean(sims$log_mt) * log(test_data$square_mt) +
mean(sims$rooms2_1) * test_data$rooms2_1 +
mean(sims$rooms2_2) * test_data$rooms2_2 +
mean(sims$rooms2_3) * test_data$rooms2_3 +
mean(sims$rooms2_4) * test_data$rooms2_4 +
mean(sims$asc) * test_data$asc +
mean(sims$wc2_2) * test_data$wc2_2 +
mean(sims$wc2_3) * test_data$wc2_3 +
mean(sims$wc2_4) * test_data$wc2_4 +
mean(sims$terraza) * test_data$terraza +
mean(sims$amueblado) * test_data$amueblado +
mean(sims$lujo) * test_data$lujo
y_pred = exp(y_pred)
y <- exp(test_data$log_price)
# Compute a measure of predictive performance
RMSE <- sqrt(mean((y_pred - y)^2))
print(RMSE)
rsquared = 1 - (sum((y - y_pred)^2)/sum((y - mean(y))^2))
adj_rsquared = 1 - ((1-rsquared)*(n-1)/(n-k-1))
print(adj_rsquared)
print(rsquared)
df_metrics[df_metrics$model == 'pooled',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'pooled',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'pooled',]$r_2_adj = round(adj_rsquared, 3)
print(df_metrics)
}
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_no_pooled.RDS") # no pooled 1435.512
tidyMCMC(fit)
df %>% filter(!grepl("sigma_y|lp_",df$term)) %>% nrow()
df = tidyMCMC(fit)
df %>% filter(!grepl("sigma_y|lp_",df$term)) %>% nrow()
df %>% filter(!grepl("sigma_y|lp_",df$term))
df %>% filter(!grepl("^b0|sigma_y|lp_",df$term))
df %>% filter(!grepl("^b0|sigma_y|lp_",df$term)) %>% nrow()
df %>% filter(!grepl("sigma_y|lp_",df$term)) %>% nrow()
NO_POOLED = TRUE
if(NO_POOLED){
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_no_pooled.RDS") # no pooled 1435.512
df = tidyMCMC(fit)
k = df %>% filter(!grepl("sigma_y|lp_",df$term)) %>% nrow()
sims <- rstan::extract(fit)
n.sims <- nrow(sims$b0)
n.test <- nrow(test_data)
y.tilde <- matrix(0, nrow = n.sims, ncol = n.test)
for (i in 1:n.test) {
# print(i)
y.tilde[,i] <- rnorm(n.sims, sims$b0[,test_data$barri[i]]
+ sims$log_smt * test_data$log_smt[i]
+ sims$rooms2_1 * test_data$rooms2_1[i]
+ sims$rooms2_2 * test_data$rooms2_2[i]
+ sims$rooms2_3 * test_data$rooms2_3[i]
+ sims$rooms2_4 * test_data$rooms2_4[i]
+ sims$asc * test_data$asc[i]
+ sims$wc2_2 * test_data$wc2_2[i]
+ sims$wc2_3 * test_data$wc2_3[i]
+ sims$wc2_4 * test_data$wc2_4[i]
+ sims$terraza * test_data$terraza[i]
+ sims$amueblado * test_data$amueblado[i]
+ sims$lujo * test_data$lujo[i]
, sims$sigma_y)
}
y.tilde.exp <- exp(y.tilde)
# Compute the predicted mean price for each observation in the test datahttp://127.0.0.1:36221/graphics/plot_zoom_png?width=2195&height=1182
predicted_means <- apply(y.tilde.exp, 2, mean)
# Compute the actual mean price for each observation in the test data
actual_means <- exp(test_data$log_price)
RMSE <- sqrt(mean((predicted_means - actual_means)^2))
print(RMSE)
rsquared = 1 - (sum((actual_means - predicted_means)^2)/sum((actual_means - mean(actual_means))^2))
adj_rsquared = 1 - ((1-rsquared)*(n-1)/(n-k-1))
print(adj_rsquared)
print(rsquared)
df_metrics[df_metrics$model == 'no_pooled',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'no_pooled',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'no_pooled',]$r_2_adj = round(adj_rsquared, 3)
print(df_metrics)
}
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(adj_rsquared)
print(rsquared)
(1-rsquared)
((n-1)/(n-k-1))
(1-rsquared)*((n-1)/(n-k-1))
n
test_data
n<-length(test_data)
n
n<-nrow(test_data)
n
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(adj_rsquared)
print(rsquared)
df_metrics[df_metrics$model == 'no_pooled',]$r_2_adj = round(adj_rsquared, 3)
print(df_metrics)
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_hierarchical_2.RDS")
tidyMCMC(fit)
df = tidyMCMC(fit)
df %>% filter(!grepl("^b0|sigma_y|lp_|mu_a|sigma_a",df$term))
f %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a",df$term)) %>% nrow()
df %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a",df$term)) %>% nrow()
HIER = TRUE
if(HIER){
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_hierarchical_2.RDS")
df = tidyMCMC(fit)
k = df %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a",df$term)) %>% nrow()
sims <- rstan::extract(fit)
# broom.mixed::tidy(sims)
n.sims <- nrow(sims$b0)
n.test <- nrow(test_data)
y.tilde <- matrix(0, nrow = n.sims, ncol = n.test)
for (i in 1:n.test) {
# print(i)
y.tilde[,i] <- rnorm(n.sims, sims$b0[,test_data$barri[i]]
+ sims$log_smt * log(test_data$square_mt[i])
+ sims$rooms2_1 * test_data$rooms2_1[i]
+ sims$rooms2_2 * test_data$rooms2_2[i]
+ sims$rooms2_3 * test_data$rooms2_3[i]
+ sims$rooms2_4 * test_data$rooms2_4[i]
+ sims$asc * test_data$asc[i]
+ sims$wc2_2 * test_data$wc2_2[i]
+ sims$wc2_3 * test_data$wc2_3[i]
+ sims$wc2_4 * test_data$wc2_4[i]
+ sims$terraza * test_data$terraza[i]
+ sims$amueblado * test_data$amueblado[i]
+ sims$lujo * test_data$lujo[i]
, sims$sigma_y)
}
y.tilde.exp <- exp(y.tilde)
# Compute the predicted mean price for each observation in the test datahttp://127.0.0.1:36221/graphics/plot_zoom_png?width=2195&height=1182
predicted_means <- apply(y.tilde.exp, 2, mean)
# Compute the actual mean price for each observation in the test data
actual_means <- exp(test_data$log_price)
RMSE <- sqrt(mean((predicted_means - actual_means)^2))
print(RMSE)
rsquared = 1 - (sum((actual_means - predicted_means)^2)/sum((actual_means - mean(actual_means))^2))
print(rsquared)
df_metrics[df_metrics$model == 'hierarchical',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'hierarchical',]$rmse = round(RMSE, 3)
print(df_metrics)
}
HIER = TRUE
if(HIER){
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_hierarchical_2.RDS")
df = tidyMCMC(fit)
k = df %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a",df$term)) %>% nrow()
sims <- rstan::extract(fit)
# broom.mixed::tidy(sims)
n.sims <- nrow(sims$b0)
n.test <- nrow(test_data)
y.tilde <- matrix(0, nrow = n.sims, ncol = n.test)
for (i in 1:n.test) {
# print(i)
y.tilde[,i] <- rnorm(n.sims, sims$b0[,test_data$barri[i]]
+ sims$log_smt * log(test_data$square_mt[i])
+ sims$rooms2_1 * test_data$rooms2_1[i]
+ sims$rooms2_2 * test_data$rooms2_2[i]
+ sims$rooms2_3 * test_data$rooms2_3[i]
+ sims$rooms2_4 * test_data$rooms2_4[i]
+ sims$asc * test_data$asc[i]
+ sims$wc2_2 * test_data$wc2_2[i]
+ sims$wc2_3 * test_data$wc2_3[i]
+ sims$wc2_4 * test_data$wc2_4[i]
+ sims$terraza * test_data$terraza[i]
+ sims$amueblado * test_data$amueblado[i]
+ sims$lujo * test_data$lujo[i]
, sims$sigma_y)
}
y.tilde.exp <- exp(y.tilde)
# Compute the predicted mean price for each observation in the test datahttp://127.0.0.1:36221/graphics/plot_zoom_png?width=2195&height=1182
predicted_means <- apply(y.tilde.exp, 2, mean)
# Compute the actual mean price for each observation in the test data
actual_means <- exp(test_data$log_price)
RMSE <- sqrt(mean((predicted_means - actual_means)^2))
print(RMSE)
rsquared = 1 - (sum((actual_means - predicted_means)^2)/sum((actual_means - mean(actual_means))^2))
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(rsquared)
df_metrics[df_metrics$model == 'hierarchical',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'hierarchical',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'hierarchical',]$r_2_adj = round(RMSE, 3)
print(df_metrics)
}
HIER = TRUE
if(HIER){
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_hierarchical_2.RDS")
df = tidyMCMC(fit)
k = df %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a",df$term)) %>% nrow()
sims <- rstan::extract(fit)
# broom.mixed::tidy(sims)
n.sims <- nrow(sims$b0)
n.test <- nrow(test_data)
y.tilde <- matrix(0, nrow = n.sims, ncol = n.test)
for (i in 1:n.test) {
# print(i)
y.tilde[,i] <- rnorm(n.sims, sims$b0[,test_data$barri[i]]
+ sims$log_smt * log(test_data$square_mt[i])
+ sims$rooms2_1 * test_data$rooms2_1[i]
+ sims$rooms2_2 * test_data$rooms2_2[i]
+ sims$rooms2_3 * test_data$rooms2_3[i]
+ sims$rooms2_4 * test_data$rooms2_4[i]
+ sims$asc * test_data$asc[i]
+ sims$wc2_2 * test_data$wc2_2[i]
+ sims$wc2_3 * test_data$wc2_3[i]
+ sims$wc2_4 * test_data$wc2_4[i]
+ sims$terraza * test_data$terraza[i]
+ sims$amueblado * test_data$amueblado[i]
+ sims$lujo * test_data$lujo[i]
, sims$sigma_y)
}
y.tilde.exp <- exp(y.tilde)
# Compute the predicted mean price for each observation in the test datahttp://127.0.0.1:36221/graphics/plot_zoom_png?width=2195&height=1182
predicted_means <- apply(y.tilde.exp, 2, mean)
# Compute the actual mean price for each observation in the test data
actual_means <- exp(test_data$log_price)
RMSE <- sqrt(mean((predicted_means - actual_means)^2))
print(RMSE)
rsquared = 1 - (sum((actual_means - predicted_means)^2)/sum((actual_means - mean(actual_means))^2))
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(rsquared)
df_metrics[df_metrics$model == 'hierarchical',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'hierarchical',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'hierarchical',]$r_2_adj = round(adj_rsquared, 3)
print(df_metrics)
}
HIER_COV = TRUE
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_9.RDS")
df = tidyMCMC(fit)
df %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a",df$term)) %>% nrow()
df %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a",df$term))
df %>% filter(!grepl("^b0|sigma_y|lp_|mu_a|sigma_a|g_0|g_1",df$term))
df %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a|g_0|g_1",df$term)) %>% nrow()
HIER_COV = TRUE
if(HIER_COV){
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_9.RDS")
df = tidyMCMC(fit)
k = df %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a|g_0|g_1",df$term)) %>% nrow()
sims <- rstan::extract(fit)
# Generate predictions for the test data
n.sims <- nrow(sims$b0)
n.test <- nrow(test_data)
y.tilde <- matrix(0, nrow = n.sims, ncol = n.test)
for (i in 1:n.test) {
# print(i) # debug
y.tilde[,i] <- rnorm(n.sims, sims$b0[,test_data$barri[i]]
+ sims$log_smt * log(test_data$square_mt[i])
+ sims$rooms2_1 * test_data$rooms2_1[i]
+ sims$rooms2_2 * test_data$rooms2_2[i]
+ sims$rooms2_3 * test_data$rooms2_3[i]
+ sims$rooms2_4 * test_data$rooms2_4[i]
+ sims$asc * test_data$asc[i]
+ sims$wc2_2 * test_data$wc2_2[i]
+ sims$wc2_3 * test_data$wc2_3[i]
+ sims$wc2_4 * test_data$wc2_4[i]
+ sims$terraza * test_data$terraza[i]
+ sims$amueblado * test_data$amueblado[i]
+ sims$lujo * test_data$lujo[i]
, sims$sigma_y)
}
# # Transform the predictions back to the original scale
y.tilde.exp <- exp(y.tilde)
# Compute the predicted mean price for each observation in the test datahttp://127.0.0.1:36221/graphics/plot_zoom_png?width=2195&height=1182
predicted_means <- apply(y.tilde.exp, 2, mean)
# Compute the actual mean price for each observation in the test data
actual_means <- exp(test_data$log_price)
# Compute a measure of predictive performance
RMSE <- sqrt(mean((predicted_means - actual_means)^2))
print(RMSE)
rsquared = 1 - (sum((actual_means - predicted_means)^2)/sum((actual_means - mean(actual_means))^2))
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(rsquared)
df_metrics[df_metrics$model == 'hierarchical_cov',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'hierarchical_cov',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'hierarchical_cov',]$r_2_adj = round(adj_rsquared, 3)
print(df_metrics)
}
lm_cook = readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/model_cook_2023-05-03.RDS")
test_data = test_data %>% filter(barri != "Ciutat Meridiana") # removing Ciutat Meridiana
unique(test_data$nom_barri)
e
lm_cook = readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/model_cook_2023-05-03.RDS")
lm_cook
unique(test_data$barri)
test_data %>% filter(barri == "Ciutat Meridiana")
lm_cook = readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/model_cook_2023-05-03.RDS")
# lm_cook
# test_data %>% filter(barri == "Ciutat Meridiana")
test_data = test_data %>% filter(barri != "Ciutat Meridiana") # removing Ciutat Meridiana
predictions = exp(predict.lm(lm_cook,predict_sample))
# Compute the actual mean price for each observation in the test data
real_values <- exp(predict_sample$log_price)
predictions = exp(predict.lm(lm_cook,test_data))
# Compute the actual mean price for each observation in the test data
real_values <- exp(test_data$log_price)
# Compute a measure of predictive performance
RMSE <- sqrt(mean((predictions - real_values)^2))
print(RMSE)
plot(real_values,predictions)
rsquared = 1 - (sum((real_values - predictions)^2)/sum((real_values - mean(real_values))^2))
print(rsquared)
# unique(test_data$barri)
lm_cook$coefficients
# unique(test_data$barri)
length(lm_cook$coefficients)
# unique(test_data$barri)
k = length(lm_cook$coefficients)
# lm_cook
# test_data %>% filter(barri == "Ciutat Meridiana")
test_data = test_data %>% filter(barri != "Ciutat Meridiana") # removing Ciutat Meridiana
predictions = exp(predict.lm(lm_cook,test_data))
# Compute the actual mean price for each observation in the test data
real_values <- exp(test_data$log_price)
# Compute a measure of predictive performance
RMSE <- sqrt(mean((predictions - real_values)^2))
print(RMSE)
plot(real_values,predictions)
rsquared = 1 - (sum((real_values - predictions)^2)/sum((real_values - mean(real_values))^2))
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(rsquared)
df_metrics[df_metrics$model == 'lm',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'lm',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'lm',]$r_2_adj = round(adj_rsquared, 3)
print(df_metrics)
source("C:/Users/ggari/Desktop/1_projects/TFM/2_code/2_R_code/4_1_predictions.R", encoding = 'UTF-8', echo=TRUE)
# Sample data: Replace this with your actual data
predicted <- c(1, 2, 3, 4, 5)
actual <- c(1.2, 1.8, 3.5, 3.8, 5.2)
neighborhood <- c('A', 'A', 'B', 'B', 'B')
# Compute the weights
weights <- 1 / table(neighborhood)
obs_weights <- weights[neighborhood]
# Compute the weighted RMSE
wrmse <- sqrt(sum(obs_weights * (actual - predicted)^2) / sum(obs_weights))
wrmse
obs_weights
test_data$id_barri
1 / table(test_data$id_barri)
obs_weights
# Compute the weights
weights <- 1 / table(neighborhood)
weights
weights
neighborhood
obs_weights
1 / table(test_data$id_barri)
weights <- 1 / table(test_data$id_barri)
obs_weights <- weights[est_data$id_barri]
obs_weights
test_data$id_barri
weights <- 1 / table(test_data$id_barri)
obs_weights <- weights[test_data$id_barri]
obs_weights
df_metrics = data.frame(model = c('lm','pooled','no_pooled','hierarchical','hierarchical_cov'),
r_2 = c(0,0,0,0,0),r_2_adj = c(0,0,0,0,0),rmse = c(0,0,0,0,0)
,wrmse = c(0,0,0,0,0))
# Sample data: Replace this with your actual data
predicted <- c(1, 2, 3, 4, 5)
actual <- c(1.2, 1.8, 3.5, 3.8, 5.2)
neighborhood <- c('A', 'A', 'B', 'B', 'B')
# Compute the weights
weights <- 1 / table(neighborhood)
obs_weights <- weights[neighborhood]
# Compute the weighted RMSE
wrmse <- sqrt(sum(obs_weights * (actual - predicted)^2) / sum(obs_weights))
wrmse
test_data$id_barri
weights <- 1 / table(test_data$id_barri)
obs_weights <- weights[test_data$id_barri]
POOLED = TRUE
if(POOLED){
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_pooled.RDS")
df = tidyMCMC(fit)
k = df %>% filter(!grepl("^b0|sigma_y|lp_",df$term)) %>% nrow()
sims <- rstan::extract(fit)
y_pred = mean(sims$b0) +
mean(sims$log_mt) * log(test_data$square_mt) +
mean(sims$rooms2_1) * test_data$rooms2_1 +
mean(sims$rooms2_2) * test_data$rooms2_2 +
mean(sims$rooms2_3) * test_data$rooms2_3 +
mean(sims$rooms2_4) * test_data$rooms2_4 +
mean(sims$asc) * test_data$asc +
mean(sims$wc2_2) * test_data$wc2_2 +
mean(sims$wc2_3) * test_data$wc2_3 +
mean(sims$wc2_4) * test_data$wc2_4 +
mean(sims$terraza) * test_data$terraza +
mean(sims$amueblado) * test_data$amueblado +
mean(sims$lujo) * test_data$lujo
y_pred = exp(y_pred)
y <- exp(test_data$log_price)
# Compute a measure of predictive performance
RMSE <- sqrt(mean((y_pred - y)^2))
wrmse <- sqrt(sum(obs_weights * (y - y_pred)^2) / sum(obs_weights))
print(RMSE)
rsquared = 1 - (sum((y - y_pred)^2)/sum((y - mean(y))^2))
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(adj_rsquared)
print(rsquared)
df_metrics[df_metrics$model == 'pooled',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'pooled',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'pooled',]$r_2_adj = round(adj_rsquared, 3)
df_metrics[df_metrics$model == 'pooled',]$wrmse = round(wrmse, 3)
print(df_metrics)
}
(y - y_pred)^2)
(y - y_pred)^2
obs_weights * (y - y_pred)^2)
(obs_weights * (y - y_pred)^2)
(sum(obs_weights * (y - y_pred)^2) / sum(obs_weights))
sum(obs_weights)
obs_weights
sum(obs_weights)
sum(obs_weights)
obs_weights >0
obs_weights <0
sum(obs_weights <0)
is.na(obs_weights)
sum(is.na(obs_weights))
is.na(test_data$id_barri)
test_data %>% filter(is.na(id_barri))
1 / table(test_data$id_barri)
sum(weights)
weights[test_data$id_barri]
obs_weights
sum(obs_weights,)
?sum
sum(obs_weights,na.rm= T)
if(POOLED){
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_pooled.RDS")
df = tidyMCMC(fit)
k = df %>% filter(!grepl("^b0|sigma_y|lp_",df$term)) %>% nrow()
sims <- rstan::extract(fit)
y_pred = mean(sims$b0) +
mean(sims$log_mt) * log(test_data$square_mt) +
mean(sims$rooms2_1) * test_data$rooms2_1 +
mean(sims$rooms2_2) * test_data$rooms2_2 +
mean(sims$rooms2_3) * test_data$rooms2_3 +
mean(sims$rooms2_4) * test_data$rooms2_4 +
mean(sims$asc) * test_data$asc +
mean(sims$wc2_2) * test_data$wc2_2 +
mean(sims$wc2_3) * test_data$wc2_3 +
mean(sims$wc2_4) * test_data$wc2_4 +
mean(sims$terraza) * test_data$terraza +
mean(sims$amueblado) * test_data$amueblado +
mean(sims$lujo) * test_data$lujo
y_pred = exp(y_pred)
y <- exp(test_data$log_price)
# Compute a measure of predictive performance
RMSE <- sqrt(mean((y_pred - y)^2))
wrmse <- sqrt(sum(obs_weights * (y - y_pred)^2) / sum(obs_weights,na.rm = T))
print(RMSE)
rsquared = 1 - (sum((y - y_pred)^2)/sum((y - mean(y))^2))
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(adj_rsquared)
print(rsquared)
df_metrics[df_metrics$model == 'pooled',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'pooled',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'pooled',]$r_2_adj = round(adj_rsquared, 3)
df_metrics[df_metrics$model == 'pooled',]$wrmse = round(wrmse, 3)
print(df_metrics)
}
wrmse <- sqrt(sum(obs_weights * (y - y_pred)^2) / sum(obs_weights,na.rm = T),na.rm = T)
wrmse <- sqrt(sum(obs_weights * (y - y_pred)^2,na.rm= T) / sum(obs_weights,na.rm = T))
wrmse
POOLED = TRUE
if(POOLED){
fit <- readRDS("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_pooled.RDS")
df = tidyMCMC(fit)
k = df %>% filter(!grepl("^b0|sigma_y|lp_",df$term)) %>% nrow()
sims <- rstan::extract(fit)
y_pred = mean(sims$b0) +
mean(sims$log_mt) * log(test_data$square_mt) +
mean(sims$rooms2_1) * test_data$rooms2_1 +
mean(sims$rooms2_2) * test_data$rooms2_2 +
mean(sims$rooms2_3) * test_data$rooms2_3 +
mean(sims$rooms2_4) * test_data$rooms2_4 +
mean(sims$asc) * test_data$asc +
mean(sims$wc2_2) * test_data$wc2_2 +
mean(sims$wc2_3) * test_data$wc2_3 +
mean(sims$wc2_4) * test_data$wc2_4 +
mean(sims$terraza) * test_data$terraza +
mean(sims$amueblado) * test_data$amueblado +
mean(sims$lujo) * test_data$lujo
y_pred = exp(y_pred)
y <- exp(test_data$log_price)
# Compute a measure of predictive performance
RMSE <- sqrt(mean((y_pred - y)^2))
wrmse <- sqrt(sum(obs_weights * (y - y_pred)^2,na.rm= T) / sum(obs_weights,na.rm = T))
print(RMSE)
rsquared = 1 - (sum((y - y_pred)^2)/sum((y - mean(y))^2))
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(adj_rsquared)
print(rsquared)
df_metrics[df_metrics$model == 'pooled',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'pooled',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'pooled',]$r_2_adj = round(adj_rsquared, 3)
df_metrics[df_metrics$model == 'pooled',]$wrmse = round(wrmse, 3)
print(df_metrics)
}
source("C:/Users/ggari/Desktop/1_projects/TFM/2_code/2_R_code/4_1_predictions.R", encoding = 'UTF-8', echo=TRUE)

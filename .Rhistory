rstan_options(auto_write=TRUE )
# install.packages("https://cran.r-project.org/src/contrib/Archive/StanHeaders/StanHeaders_2.21.0-7.tar.gz",
#                  type="source",repos=NULL)
packageVersion("StanHeaders")
packageVersion("rstan")
data_date = "2023-05-03"
path_modelling = paste0("data_lm_cook_",data_date,".RDS")
data_cook<- readRDS(here::here('Desktop','1_projects','TFM','1_data','2_data_Idealista',path_modelling))
data_cook$barri <- as.factor(data_cook$barri)
# no lujo?
data_cook = data_cook %>% filter(lujo == 0)
names(data_cook)
N= nrow(data_cook)
barri_name <- unique(data_cook$barri)
barri <- as.numeric(data_cook$barri)
J <- length(unique(barri))
y <- data_cook$log_price
x1 <- log(data_cook$square_mt)
x2 <- data_cook$rooms2_1
x3 <- data_cook$rooms2_2
x4 <- data_cook$rooms2_3
x5 <- data_cook$rooms2_4
x6 <- data_cook$asc
x7 <- data_cook$wc2_2
x8 <- data_cook$wc2_3
x9 <- data_cook$wc2_4
x10 <- data_cook$terraza
x11 <- data_cook$amueblado
x12 <- data_cook$lujo
mean_income <- data_cook %>%
group_by(barri) %>%
summarise(mean_income = first(log(mean_income))) %>%
pull(mean_income)
data_list <- list(
N = N,
y = y,
J = J,
x1 = x1,
x2 = x2,
x3 = x3,
x4 = x4,
x5 = x5,
x6 = x6,
x7 = x7,
x8 = x8,
x9 = x9,
x10 = x10,
x11 = x11,
x12 = x12,
barri = barri,
mean_income = mean_income
)
#   f ~ cauchy(0,2.5);
#   b6 ~ cauchy(0,2.5);
#   for (j in 1:J)
#     a[j] ~ normal(g_0 + g_1 * mean_income[j], sigma_a);
#   for (n in 1:N)
#     y[n] ~ normal(a[barri[n]] + b * x1[n] + c * x2[n] + d * x3[n]
#     //+ e * x4[n]
#      + f * x5[n] + b6 * terraza[n] , sigma_y);
# }
# "
model_code <- "
data {
int<lower=0> N;
int<lower=0> J;
vector[N] y;
real x1[N];
int x2[N];
int x3[N];
int x4[N];
int x5[N];
int x6[N];
int x7[N];
int x8[N];
int x9[N];
int x10[N];
int x11[N];
int x12[N];
int barri[N];
vector[J] mean_income;
}
parameters {
real b0[J];
real log_smt; // log square mt
real rooms2_1 ; // rooms
real rooms2_2; // rooms
real rooms2_3; // rooms
real rooms2_4; // rooms
real asc; // asc
real wc2_2; // wc
real wc2_3; // wc
real wc2_4; // wc
real terraza;
real amueblado;
real lujo;
real g_0;
real g_1;
real<lower=0> sigma_y;
real<lower=0> sigma_a;
}
model {
sigma_y ~ cauchy(0, 10);
sigma_a ~ cauchy(0, 10);
// g_0 ~ cauchy(0,10);
// g_1 ~cauchy(0,10);
log_smt ~ cauchy(0,2.5);
rooms2_1 ~ cauchy(0,2.5);
rooms2_2 ~ cauchy(0,2.5);
rooms2_3 ~ cauchy(0,2.5);
rooms2_4 ~ cauchy(0,2.5);
asc ~ cauchy(0,2.5);
wc2_2 ~ cauchy(0,2.5);
wc2_3 ~ cauchy(0,2.5);
wc2_4 ~ cauchy(0,2.5);
terraza ~ cauchy(0,2.5);
amueblado ~ cauchy(0,2.5);
lujo ~ cauchy(0,2.5);
for (j in 1:J)
b0[j] ~ normal(g_0 + g_1 * mean_income[j], sigma_a);
for (n in 1:N)
y[n] ~ normal(b0[barri[n]] + log_smt * x1[n] + rooms2_1 * x2[n] +
rooms2_2 * x3[n] + rooms2_3 * x4[n] + rooms2_4 * x5[n] +
asc * x6[n] + wc2_2 * x7[n] + wc2_3 * x8[n] + wc2_4 * x9[n] +
terraza * x10[n] + amueblado * x11[n] + lujo * x12[n], sigma_y);
}
"
translate = stanc(model_code  = model_code)
model = stan_model(stanc_ret = translate)
# Fit the model to the data
fit_4 <- sampling(model, data = data_list, chains = 4, iter =5000, verbose = TRUE, seed = 132) # 4000?
# path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_priors.RDS") # with priors
# path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_1.RDS") # wc cov
# path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_2.RDS") # terrace
# path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_2_1.RDS") # lujo cauchy narrow
# path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_3.RDS") # asc
# path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_4.RDS") # terraza
# path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_5.RDS") # playa
# path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_6.RDS") # intercept: playa+renta
# path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_7.RDS") # varying the slope # no converge
# path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_8.RDS") # no lujo data
path_to_save = paste0("C:/Users/ggari/Desktop/1_projects/TFM/1_data/2_data_Idealista/3_fitted_data/model_4_9.RDS") # all variables
saveRDS(fit_4, path_to_save)
# ## Convergence analysis
print(fit_4) # Cuando hay porblemas de multicolinearidad max depth sube y r-hat
setwd("C:/Users/ggari/Desktop/1_projects/TFM")
library(shiny); runApp('2_code/2_R_code/shiny_app/5_shiny_app.R')
file_path = "concat_shiny.RDS"
barcelona_rent<- readRDS(here::here('1_data','2_data_Idealista',file_path))
names(barcelona_rent)
barcelona_rent = barcelona_rent %>% filter(lujo == 0)
path_shp_barcelona = here::here("1_data","3_data_Barris_Barcelona","barris_clean.shp")
barcelona_shape <- sf::st_read(path_shp_barcelona)
names(barcelona_rent)
barcelona_rent_gp = barcelona_shape %>% mutate(id_barri = as.numeric(BARRI)) %>% left_join(barcelona_rent %>% select(id_barri,price,square_mt,rooms) %>%
group_by(id_barri) %>% summarise_all(mean), by = c("id_barri")) %>% ungroup()
barcelona_rent_gp <- st_transform(barcelona_rent_gp, "+proj=longlat +datum=WGS84")
barcelona_rent_gp$price =  round(barcelona_rent_gp$price,1)
fit <- readRDS("./1_data/2_data_Idealista/3_fitted_data/model_4_9.RDS") # modelo
# Define the UI
ui <- fluidPage(
titlePanel("Precios Alquiler Barcelona"),
navbarPage(
"Barcelona Rent Prediction",
tabPanel("Map",
leafletOutput("map")),
tabPanel("Select Features",
selectInput("neighborhood", "Barrio:",
choices = unique(barcelona_rent_gp$NOM)),
selectInput("bedrooms", "Número de habitaciones:",
choices = c("0", "1", "2", "3", "4 o más"),
selectize = FALSE),
selectInput("bathrooms", "Número de baños:",
choices = c("1", "2", "3", "4 o más"),
selectize = FALSE),
checkboxInput("furnished", "Amueblado", value = FALSE),
checkboxInput("terrace", "Terraza", value = FALSE),
checkboxInput("lift", "Ascensor", value = FALSE),
checkboxInput("luxe", "Lujo", value = FALSE),
textInput("sqmeters", "Metros Cuadrados:", value = "500"),
actionButton("predictButton", "Generar Predicción"),
# Agregar la pestaña "Results" dentro de "Select Features"
conditionalPanel(
condition = "input.predictButton > 0",
tabsetPanel(
tabPanel("Results",
tableOutput("predictionTable")
)
)
),
# Agregar una pestaña para el histograma y el control deslizante de bins
plotOutput("priceHistogram")
)
)
)
# Define the server logic
server <- function(input, output) {
# Render the map
output$map <- renderLeaflet({
leaflet() %>%
addTiles() %>%
addPolygons(
data = barcelona_rent_gp,
fillColor = ~colorPalette()(price),
fillOpacity = 0.7,
color = "white",
weight = 1,
popup = ~paste0("<b>Barrio: </b>", NOM,
"<br><b>Precio medio: </b>", price, "€")
) %>%
addLegend(
position = "bottomright",
pal = colorPalette(),
values = barcelona_rent_gp$price,
title = "Precio medio alquiler (€)",
opacity = 1
)
})
# Define the color palette for the map polygons
colorPalette <- reactive({
colorNumeric(
palette = "Blues",
domain = barcelona_rent_gp$price
)
})
# Crear una variable reactiva para almacenar las predicciones lineales
linear_predictions <- reactive({
# Obtener los valores seleccionados por el usuario
selected_neighborhood <- input$neighborhood
selected_bedrooms <- input$bedrooms
selected_bathrooms <- input$bathrooms
selected_furnished <- input$furnished
selected_terrace <- input$terrace
selected_lift <- input$lift
selected_luxe <- input$luxe
selected_sqmeters <- as.numeric(input$sqmeters)  # Asegurarse de que sea numérico
# Asumiendo que tienes el modelo previamente ajustado en `fit`
sims <- rstan::extract(fit)
# Definir los valores de las características para la predicción
neighborhood_value <- selected_neighborhood
rooms2_1 <- ifelse(selected_bedrooms == '1',1,0)
rooms2_2 <-ifelse(selected_bedrooms == '2',1,0)
rooms2_3 <- ifelse(selected_bedrooms == '3',1,0)  # Puedes ajustar estos valores según las selecciones del usuario
rooms2_4 <- ifelse(selected_bedrooms == '4 o más',1,0)
wc2_2 <- ifelse(selected_bathrooms == '2',1,0)
wc2_3 <- ifelse(selected_bathrooms == '3',1,0)
wc2_4 <- ifelse(selected_bathrooms == '4 o más',1,0)
terraza <- ifelse(selected_terrace, 1, 0)
asc <- ifelse(selected_lift, 1, 0)
smt <- log(selected_sqmeters)
lujo <- ifelse(selected_luxe, 1, 0)
amueblado <- ifelse(selected_furnished, 1, 0)
# Inicializar un vector para almacenar las predicciones lineales
n.sims <- nrow(sims$b0)
linear_predictions <- numeric(n.sims)
# Calcular las predicciones lineales para cada muestra
for (i in 1:n.sims) {
linear_predictions[i] <- sims$b0[i, 1] + # 1 neighborhood_value
rooms2_1 * sims$rooms2_1[i] +
rooms2_2 * sims$rooms2_2[i] +
rooms2_3 * sims$rooms2_3[i] +
rooms2_4 * sims$rooms2_4[i] +
wc2_2 * sims$wc2_2[i] +
wc2_3* sims$wc2_3[i] +
wc2_4* sims$wc2_4[i] +
terraza * sims$terraza[i] +
asc * sims$asc[i] +
smt * sims$log_smt[i] +
lujo * sims$lujo[i] +
amueblado * sims$amueblado[i]
}
# Calcular las predicciones de precios usando el modelo
predicted_prices <- exp(linear_predictions)
return(predicted_prices)
})
# Crear una función para renderizar el histograma
output$priceHistogram <- renderPlot({
# Obtener el número de bins seleccionados por el usuario
bins <- 30
# Crear un dataframe con las predicciones
prices_df <- data.frame(Precio_Predicho = linear_predictions())
# Crear el histograma usando ggplot2
ggplot(prices_df, aes(x = Precio_Predicho)) +
geom_histogram(binwidth = (max(prices_df$Precio_Predicho) - min(prices_df$Precio_Predicho)) / bins
, fill = "#00B8E7") +
labs(title = "Distribución de Precios Predichos",
x = "Precio Predicho") +
theme_minimal()
})
# Calcular las predicciones de precios, crear la tabla de resultados y mostrarla
observe({
# Obtener las predicciones lineales
preds <- linear_predictions()
# Calcular las predicciones de precios usando el modelo
predicted_prices <- (preds)
mean_predicted_price <- mean(predicted_prices)
# Obtener los valores seleccionados por el usuario
selected_neighborhood <- input$neighborhood
selected_bedrooms <- input$bedrooms
selected_bathrooms <- input$bathrooms
selected_furnished <- input$furnished
selected_terrace <- input$terrace
selected_lift <- input$lift
selected_luxe <- input$luxe
selected_sqmeters <- as.numeric(input$sqmeters)
# Crear una tabla de resultados
results_df <- data.frame(
Barrio = selected_neighborhood,
Metros_cuadrados = selected_sqmeters,
Habitaciones = selected_bedrooms,
Baños = selected_bathrooms,
Amueblado = ifelse(selected_furnished, "Sí", "No"),
Terraza = ifelse(selected_terrace, "Sí", "No"),
Ascensor = ifelse(selected_lift, "Sí", "No"),
Lujo = ifelse(selected_luxe, "Sí", "No"),
Precio_Predicho = mean_predicted_price
)
# Mostrar la tabla de resultados
output$predictionTable <- renderTable({
results_df
})
})
}
# Run the Shiny app
shinyApp(ui = ui, server = server)
mpaping = here("1_data","2_data_Idealista","mapping_barri_coeff.rds")
library(here)
mpaping = here("1_data","2_data_Idealista","mapping_barri_coeff.rds")
mapping = readRDS(mpaping)
mapping
names(mapping)
row.names(mapping)
row.names(mapping %>% filter(barri_name == 'Can Baró'))
row.names(mapping %>% filter(barri_name == 'el Clot'))
mapping$num = 1:65
mapping
filter(mapping, barri_name == 'el Clot')
filter(mapping, barri_name == 'el Clot')$num
11
# Define the UI
ui <- fluidPage(
titlePanel("Precios Alquiler Barcelona"),
navbarPage(
"Barcelona Rent Prediction",
tabPanel("Map",
leafletOutput("map")),
tabPanel("Select Features",
selectInput("neighborhood", "Barrio:",
choices = unique(barcelona_rent_gp$NOM)),
selectInput("bedrooms", "Número de habitaciones:",
choices = c("0", "1", "2", "3", "4 o más"),
selectize = FALSE),
selectInput("bathrooms", "Número de baños:",
choices = c("1", "2", "3", "4 o más"),
selectize = FALSE),
checkboxInput("furnished", "Amueblado", value = FALSE),
checkboxInput("terrace", "Terraza", value = FALSE),
checkboxInput("lift", "Ascensor", value = FALSE),
checkboxInput("luxe", "Lujo", value = FALSE),
textInput("sqmeters", "Metros Cuadrados:", value = "500"),
actionButton("predictButton", "Generar Predicción"),
# Agregar la pestaña "Results" dentro de "Select Features"
conditionalPanel(
condition = "input.predictButton > 0",
tabsetPanel(
tabPanel("Results",
tableOutput("predictionTable")
)
)
),
# Agregar una pestaña para el histograma y el control deslizante de bins
plotOutput("priceHistogram")
)
)
)
# Define the server logic
server <- function(input, output) {
# Render the map
output$map <- renderLeaflet({
leaflet() %>%
addTiles() %>%
addPolygons(
data = barcelona_rent_gp,
fillColor = ~colorPalette()(price),
fillOpacity = 0.7,
color = "white",
weight = 1,
popup = ~paste0("<b>Barrio: </b>", NOM,
"<br><b>Precio medio: </b>", price, "€")
) %>%
addLegend(
position = "bottomright",
pal = colorPalette(),
values = barcelona_rent_gp$price,
title = "Precio medio alquiler (€)",
opacity = 1
)
})
# Define the color palette for the map polygons
colorPalette <- reactive({
colorNumeric(
palette = "Blues",
domain = barcelona_rent_gp$price
)
})
# Crear una variable reactiva para almacenar las predicciones lineales
linear_predictions <- reactive({
# Obtener los valores seleccionados por el usuario
selected_neighborhood <- input$neighborhood
selected_bedrooms <- input$bedrooms
selected_bathrooms <- input$bathrooms
selected_furnished <- input$furnished
selected_terrace <- input$terrace
selected_lift <- input$lift
selected_luxe <- input$luxe
selected_sqmeters <- as.numeric(input$sqmeters)  # Asegurarse de que sea numérico
# Asumiendo que tienes el modelo previamente ajustado en `fit`
sims <- rstan::extract(fit)
barrio_index = filter(mapping, barri_name == selected_neighborhood)$num
# Definir los valores de las características para la predicción
neighborhood_value <- selected_neighborhood
rooms2_1 <- ifelse(selected_bedrooms == '1',1,0)
rooms2_2 <-ifelse(selected_bedrooms == '2',1,0)
rooms2_3 <- ifelse(selected_bedrooms == '3',1,0)  # Puedes ajustar estos valores según las selecciones del usuario
rooms2_4 <- ifelse(selected_bedrooms == '4 o más',1,0)
wc2_2 <- ifelse(selected_bathrooms == '2',1,0)
wc2_3 <- ifelse(selected_bathrooms == '3',1,0)
wc2_4 <- ifelse(selected_bathrooms == '4 o más',1,0)
terraza <- ifelse(selected_terrace, 1, 0)
asc <- ifelse(selected_lift, 1, 0)
smt <- log(selected_sqmeters)
lujo <- ifelse(selected_luxe, 1, 0)
amueblado <- ifelse(selected_furnished, 1, 0)
# Inicializar un vector para almacenar las predicciones lineales
n.sims <- nrow(sims$b0)
linear_predictions <- numeric(n.sims)
# Calcular las predicciones lineales para cada muestra
for (i in 1:n.sims) {
linear_predictions[i] <- sims$b0[i, barrio_index] + # 1 neighborhood_value
rooms2_1 * sims$rooms2_1[i] +
rooms2_2 * sims$rooms2_2[i] +
rooms2_3 * sims$rooms2_3[i] +
rooms2_4 * sims$rooms2_4[i] +
wc2_2 * sims$wc2_2[i] +
wc2_3* sims$wc2_3[i] +
wc2_4* sims$wc2_4[i] +
terraza * sims$terraza[i] +
asc * sims$asc[i] +
smt * sims$log_smt[i] +
lujo * sims$lujo[i] +
amueblado * sims$amueblado[i]
}
# Calcular las predicciones de precios usando el modelo
predicted_prices <- exp(linear_predictions)
return(predicted_prices)
})
# Crear una función para renderizar el histograma
output$priceHistogram <- renderPlot({
# Obtener el número de bins seleccionados por el usuario
bins <- 30
# Crear un dataframe con las predicciones
prices_df <- data.frame(Precio_Predicho = linear_predictions())
# Crear el histograma usando ggplot2
ggplot(prices_df, aes(x = Precio_Predicho)) +
geom_histogram(binwidth = (max(prices_df$Precio_Predicho) - min(prices_df$Precio_Predicho)) / bins
, fill = "#00B8E7") +
labs(title = "Distribución de Precios Predichos",
x = "Precio Predicho") +
theme_minimal()
})
# Calcular las predicciones de precios, crear la tabla de resultados y mostrarla
observe({
# Obtener las predicciones lineales
preds <- linear_predictions()
# Calcular las predicciones de precios usando el modelo
predicted_prices <- (preds)
mean_predicted_price <- mean(predicted_prices)
# Obtener los valores seleccionados por el usuario
selected_neighborhood <- input$neighborhood
selected_bedrooms <- input$bedrooms
selected_bathrooms <- input$bathrooms
selected_furnished <- input$furnished
selected_terrace <- input$terrace
selected_lift <- input$lift
selected_luxe <- input$luxe
selected_sqmeters <- as.numeric(input$sqmeters)
# Crear una tabla de resultados
results_df <- data.frame(
Barrio = selected_neighborhood,
Metros_cuadrados = selected_sqmeters,
Habitaciones = selected_bedrooms,
Baños = selected_bathrooms,
Amueblado = ifelse(selected_furnished, "Sí", "No"),
Terraza = ifelse(selected_terrace, "Sí", "No"),
Ascensor = ifelse(selected_lift, "Sí", "No"),
Lujo = ifelse(selected_luxe, "Sí", "No"),
Precio_Predicho = mean_predicted_price
)
# Mostrar la tabla de resultados
output$predictionTable <- renderTable({
results_df
})
})
}
# Run the Shiny app
shinyApp(ui = ui, server = server)
# Asumiendo que tienes el modelo previamente ajustado en `fit`
sims <- rstan::extract(fit)
mean(sims$rooms2_4)
mean(sims$rooms2_3)
mean(sims$rooms2_2)
mean(sims$rooms2_1)

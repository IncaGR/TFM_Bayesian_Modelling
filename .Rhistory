print(rsquared)
df_metrics[df_metrics$model == 'no_pooled',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'no_pooled',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'no_pooled',]$r_2_adj = round(adj_rsquared, 3)
df_metrics[df_metrics$model == 'no_pooled',]$wrmse = round(wrmse, 3)
print(df_metrics)
}
HIER = FALSE
if(HIER){
fit <- readRDS("./1_data/2_data_Idealista/3_fitted_data/model_hierarchical_2.RDS")
df = tidyMCMC(fit)
k = df %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a",df$term)) %>% nrow()
sims <- rstan::extract(fit)
# broom.mixed::tidy(sims)
n.sims <- nrow(sims$b0)
n.test <- nrow(test_data)
y.tilde <- matrix(0, nrow = n.sims, ncol = n.test)
for (i in 1:n.test) {
# print(i)
y.tilde[,i] <- rnorm(n.sims, sims$b0[,test_data$barri[i]]
+ sims$log_smt * log(test_data$square_mt[i])
+ sims$rooms2_1 * test_data$rooms2_1[i]
+ sims$rooms2_2 * test_data$rooms2_2[i]
+ sims$rooms2_3 * test_data$rooms2_3[i]
+ sims$rooms2_4 * test_data$rooms2_4[i]
+ sims$asc * test_data$asc[i]
+ sims$wc2_2 * test_data$wc2_2[i]
+ sims$wc2_3 * test_data$wc2_3[i]
+ sims$wc2_4 * test_data$wc2_4[i]
+ sims$terraza * test_data$terraza[i]
+ sims$amueblado * test_data$amueblado[i]
+ sims$lujo * test_data$lujo[i]
, sims$sigma_y)
}
y.tilde.exp <- exp(y.tilde)
# Compute the predicted mean price for each observation in the test datahttp://127.0.0.1:36221/graphics/plot_zoom_png?width=2195&height=1182
predicted_means <- apply(y.tilde.exp, 2, mean)
# Compute the actual mean price for each observation in the test data
actual_means <- exp(test_data$log_price)
RMSE <- sqrt(mean((predicted_means - actual_means)^2))
wrmse <- sqrt(sum(obs_weights * (predicted_means - actual_means)^2,na.rm= T) / sum(obs_weights,na.rm = T))
print(RMSE)
rsquared = 1 - (sum((actual_means - predicted_means)^2)/sum((actual_means - mean(actual_means))^2))
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(rsquared)
df_metrics[df_metrics$model == 'hierarchical',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'hierarchical',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'hierarchical',]$r_2_adj = round(adj_rsquared, 3)
df_metrics[df_metrics$model == 'hierarchical',]$wrmse = round(wrmse, 3)
print(df_metrics)
}
HIER_COV = TRUE
if(HIER_COV){
fit <- readRDS("./1_data/2_data_Idealista/3_fitted_data/model_4_9.RDS")
df = tidyMCMC(fit)
k = df %>% filter(!grepl("sigma_y|lp_|mu_a|sigma_a|g_0|g_1",df$term)) %>% nrow()
sims <- rstan::extract(fit)
# Generate predictions for the test data
n.sims <- nrow(sims$b0)
n.test <- nrow(test_data)
y.tilde <- matrix(0, nrow = n.sims, ncol = n.test)
for (i in 1:n.test) {
# print(i) # debug
y.tilde[,i] <- rnorm(n.sims, sims$b0[,test_data$barri[i]]
+ sims$log_smt * log(test_data$square_mt[i])
+ sims$rooms2_1 * test_data$rooms2_1[i]
+ sims$rooms2_2 * test_data$rooms2_2[i]
+ sims$rooms2_3 * test_data$rooms2_3[i]
+ sims$rooms2_4 * test_data$rooms2_4[i]
+ sims$asc * test_data$asc[i]
+ sims$wc2_2 * test_data$wc2_2[i]
+ sims$wc2_3 * test_data$wc2_3[i]
+ sims$wc2_4 * test_data$wc2_4[i]
+ sims$terraza * test_data$terraza[i]
+ sims$amueblado * test_data$amueblado[i]
+ sims$lujo * test_data$lujo[i]
, sims$sigma_y)
}
# # Transform the predictions back to the original scale
y.tilde.exp <- exp(y.tilde)
# Compute the predicted mean price for each observation in the test datahttp://127.0.0.1:36221/graphics/plot_zoom_png?width=2195&height=1182
predicted_means <- apply(y.tilde.exp, 2, mean)
# Compute the actual mean price for each observation in the test data
actual_means <- exp(test_data$log_price)
# Compute a measure of predictive performance
RMSE <- sqrt(mean((predicted_means - actual_means)^2))
wrmse <- sqrt(sum(obs_weights * (actual_means - predicted_means)^2,na.rm= T) / sum(obs_weights,na.rm = T))
print(RMSE)
rsquared = 1 - (sum((actual_means - predicted_means)^2)/sum((actual_means - mean(actual_means))^2))
adj_rsquared = 1 - (1-rsquared)*((n-1)/(n-k-1))
print(rsquared)
df_metrics[df_metrics$model == 'hierarchical_cov',]$r_2 = round(rsquared, 3)
df_metrics[df_metrics$model == 'hierarchical_cov',]$rmse = round(RMSE, 3)
df_metrics[df_metrics$model == 'hierarchical_cov',]$r_2_adj = round(adj_rsquared, 3)
df_metrics[df_metrics$model == 'hierarchical_cov',]$wrmse = round(wrmse, 3)
print(df_metrics)
}
View(df)
fit
fit$`b0[1]`
`b0[1]`
fit[`b0[1]`]
fit["b0[1]"]
names(fit)
fit$b0[1]
fit@sim
fit@sim$samples
fit
fit@model_name
fit@model_pars
fit@date
fit@stanmodel
fit@inis
fit@inits
fit[["b0"]]
fit@stan_args
fit@model_pars
df
k
tail(df)
tail(df,10)
tail(df,20)
tail(df,16)
fit@sim$samples
fit@`b0[1]`
fit$sigma_a
fit$rooms2_2
View(fit)
fit@sim$samples$[[1]]
fit@sim$samples$1
sims
sims
sims$b0
mapp
names(sims)
nrow(sims$b0)
numeric(length(b0_samples))
# Extract the posterior samples for coefficients (assuming your model has a linear structure)
b0_samples <- sims$b0  # Assuming you have a variable named 'b0' in your model
numeric(length(b0_samples))
b0_samples
length(b0_samples)
numeric(length(b0_samples))
n.sims
b0_samples
# Extract the posterior samples for coefficients (assuming your model has a linear structure)
b0_samples <- sims$b0  # Assuming you have a variable named 'b0' in your model
# Initialize an empty vector to store the linear predictions
linear_predictions <- numeric(length(b0_samples))
sims$rooms2_4
length(sims$rooms2_4)
# Extract the posterior samples for coefficients (assuming your model has a linear structure)
b0_samples <- sims$b0  # Assuming you have a variable named 'b0' in your model
b0_samples
# Extract the posterior samples for coefficients (assuming your model has a linear structure)
b0_samples <- sims$b0  # Assuming you have a variable named 'b0' in your model
n.sims
n.test
y.tilde
dim(y.tilde)
sims$rooms2_coef
sims$rooms2_4
sims$b0
lenght(sims$b0)
length(sims$b0)
numeric(n.sims)
numeric(n.sims)
sims$b0
sims$b0[]
sims$b0[,65]
asc <- 1
# Define values for the predictors
neighborhood_value <- 5
rooms2_4 <- 1
wc2_2 <- 1
terraza <- 1
asc <- 1
smt <- 80
linear_predictions <- numeric(n.sims)
# Loop through each posterior sample to calculate the linear prediction
for (i in 1:n.sims) {
linear_predictions[i] <- b0_samples[i, neighborhood_value] +
rooms2_4 * sims$rooms2_4[i] +
wc2_2 * sims$wc2_2[i] +
terraza * sims$terraza[i] +
asc * sims$asc[i] +
log(smt) * sims$log_smt[i]
}
# Assuming your model involves log-transformed price
predicted_prices <- exp(linear_predictions)
# Calculate summary statistics
mean_predicted_price <- mean(predicted_prices)
median_predicted_price <- median(predicted_prices)
credible_interval <- quantile(predicted_prices, c(0.025, 0.975))
mean_predicted_price
median_predicted_price
credible_interval
linear_predictions <- numeric(n.sims)
# Loop through each posterior sample to calculate the linear prediction
for (i in 1:n.sims) {
linear_predictions[i] <- b0_samples[i, neighborhood_value] +
rooms2_4 * sims$rooms2_4[i] +
wc2_2 * sims$wc2_2[i] +
terraza * sims$terraza[i] +
asc * sims$asc[i] +
log(smt) * sims$log_smt[i] +
lujo * sims$lujo[i]
}
lujo <- 1
linear_predictions <- numeric(n.sims)
# Loop through each posterior sample to calculate the linear prediction
for (i in 1:n.sims) {
linear_predictions[i] <- b0_samples[i, neighborhood_value] +
rooms2_4 * sims$rooms2_4[i] +
wc2_2 * sims$wc2_2[i] +
terraza * sims$terraza[i] +
asc * sims$asc[i] +
log(smt) * sims$log_smt[i] +
lujo * sims$lujo[i]
}
# Assuming your model involves log-transformed price
predicted_prices <- exp(linear_predictions)
# Calculate summary statistics
mean_predicted_price <- mean(predicted_prices)
median_predicted_price <- median(predicted_prices)
credible_interval <- quantile(predicted_prices, c(0.025, 0.975))
mean_predicted_price
median_predicted_price
credible_interval
names(sims)
# Define values for the predictors
neighborhood_value <- 5
rooms2_4 <- 1
wc2_4 <- 1
terraza <- 1
asc <- 1
smt <- 250
lujo <- 1
amueblado <- 1
# Define values for the predictors
neighborhood_value <- 5
rooms2_4 <- 1
wc2_4 <- 1
terraza <- 1
asc <- 1
smt <- 250
lujo <- 1
amueblado <- 1
linear_predictions <- numeric(n.sims)
# Loop through each posterior sample to calculate the linear prediction
for (i in 1:n.sims) {
linear_predictions[i] <- b0_samples[i, neighborhood_value] +
rooms2_4 * sims$rooms2_4[i] +
wc2_2 * sims$wc2_2[i] +
terraza * sims$terraza[i] +
asc * sims$asc[i] +
log(smt) * sims$log_smt[i] +
lujo * sims$lujo[i] +
amueblado * sims$amueblado[i]
}
# Assuming your model involves log-transformed price
predicted_prices <- exp(linear_predictions)
# Calculate summary statistics
mean_predicted_price <- mean(predicted_prices)
median_predicted_price <- median(predicted_prices)
credible_interval <- quantile(predicted_prices, c(0.025, 0.975))
mean_predicted_price
hist(predicted_prices)
mpaping = here("1_data","2_data_Idealista","mapping_barri_coeff.rds")
mapping = readRDS(mpaping)
mapping
# Define values for the predictors
neighborhood_value <- 11
rooms2_3 <- 1
rooms2_4 <- 0
wc2_2 <- 1
wc2_4 <- 0
terraza <- 1
asc <- 1
smt <- 90
lujo <- 0
# Define values for the predictors
neighborhood_value <- 11
rooms2_2 <- 1
rooms2_4 <- 0
wc2_2 <- 1
wc2_4 <- 0
terraza <- 1
asc <- 1
smt <- 90
lujo <- 0
amueblado <- 0
linear_predictions <- numeric(n.sims)
# Loop through each posterior sample to calculate the linear prediction
for (i in 1:n.sims) {
linear_predictions[i] <- b0_samples[i, neighborhood_value] +
rooms2_3 * sims$rooms2_3[i] +
rooms2_4 * sims$rooms2_4[i] +
wc2_2 * sims$wc2_2[i] +
terraza * sims$terraza[i] +
asc * sims$asc[i] +
log(smt) * sims$log_smt[i] +
lujo * sims$lujo[i] +
amueblado * sims$amueblado[i]
}
# Assuming your model involves log-transformed price
predicted_prices <- exp(linear_predictions)
# Calculate summary statistics
mean_predicted_price <- mean(predicted_prices)
median_predicted_price <- median(predicted_prices)
credible_interval <- quantile(predicted_prices, c(0.025, 0.975))
hist(predicted_prices)
print(mean_predicted_price, median_predicted_price)
print(mean_predicted_price)
# Define values for the predictors
neighborhood_value <- 11
rooms2_2 <- 0
rooms2_3 <- 0
rooms2_4 <- 1
wc2_2 <- 1
wc2_4 <- 0
terraza <- 1
asc <- 1
smt <- 90
lujo <- 0
amueblado <- 0
linear_predictions <- numeric(n.sims)
# Loop through each posterior sample to calculate the linear prediction
for (i in 1:n.sims) {
linear_predictions[i] <- b0_samples[i, neighborhood_value] +
rooms2_3 * sims$rooms2_3[i] +
rooms2_4 * sims$rooms2_4[i] +
wc2_2 * sims$wc2_2[i] +
terraza * sims$terraza[i] +
asc * sims$asc[i] +
log(smt) * sims$log_smt[i] +
lujo * sims$lujo[i] +
amueblado * sims$amueblado[i]
}
# Assuming your model involves log-transformed price
predicted_prices <- exp(linear_predictions)
# Calculate summary statistics
mean_predicted_price <- mean(predicted_prices)
median_predicted_price <- median(predicted_prices)
credible_interval <- quantile(predicted_prices, c(0.025, 0.975))
print(mean_predicted_price)
hist(predicted_prices)
mapping
# Define values for the predictors
neighborhood_value <- 9
rooms2_2 <- 0
rooms2_3 <- 0
rooms2_4 <- 1
wc2_2 <- 1
wc2_4 <- 0
terraza <- 1
asc <- 1
smt <- 90
lujo <- 0
amueblado <- 0
linear_predictions <- numeric(n.sims)
# Loop through each posterior sample to calculate the linear prediction
for (i in 1:n.sims) {
linear_predictions[i] <- b0_samples[i, neighborhood_value] +
rooms2_3 * sims$rooms2_3[i] +
rooms2_4 * sims$rooms2_4[i] +
wc2_2 * sims$wc2_2[i] +
terraza * sims$terraza[i] +
asc * sims$asc[i] +
log(smt) * sims$log_smt[i] +
lujo * sims$lujo[i] +
amueblado * sims$amueblado[i]
}
# Assuming your model involves log-transformed price
predicted_prices <- exp(linear_predictions)
# Calculate summary statistics
mean_predicted_price <- mean(predicted_prices)
median_predicted_price <- median(predicted_prices)
credible_interval <- quantile(predicted_prices, c(0.025, 0.975))
print(mean_predicted_price)
hist(predicted_prices)
names(sims)
library(shiny)
library(leaflet)
library(dplyr)
# Define the UI
ui <- fluidPage(
titlePanel("Precios Alquiler Barcelona"),
navbarPage(
"Barcelona Rent Prediction",
tabPanel("Map",
leafletOutput("map")),
tabPanel("Select Features",
selectInput("neighborhood", "Barrio:",
choices = unique(barcelona_rent_gp$NOM)),
sliderInput("bedrooms", "Número de habitaciones:",
min = 1, max = 10, value = 4),
checkboxInput("furnished", "Amueblado", value = FALSE),
sliderInput("bathrooms", "Número de baños:",
min = 1, max = 5, value = 2),
actionButton("predictButton", "Generar Predicción")
),
tabPanel("Results",
tableOutput("predictionTable")
)
)
)
file_path = "concat_shiny.RDS"
barcelona_rent<- readRDS(here::here('1_data','2_data_Idealista',file_path))
names(barcelona_rent)
barcelona_rent = barcelona_rent %>% filter(lujo == 0)
path_shp_barcelona = here::here("1_data","3_data_Barris_Barcelona","barris_clean.shp")
barcelona_shape <- sf::st_read(path_shp_barcelona)
names(barcelona_rent)
barcelona_rent_gp = barcelona_shape %>% mutate(id_barri = as.numeric(BARRI)) %>% left_join(barcelona_rent %>% select(id_barri,price,square_mt,rooms) %>%
group_by(id_barri) %>% summarise_all(mean), by = c("id_barri")) %>% ungroup()
barcelona_rent_gp <- st_transform(barcelona_rent_gp, "+proj=longlat +datum=WGS84")
library(shiny)
library(leaflet)
library(dplyr)
library(sf)
file_path = "concat_shiny.RDS"
barcelona_rent<- readRDS(here::here('1_data','2_data_Idealista',file_path))
names(barcelona_rent)
barcelona_rent = barcelona_rent %>% filter(lujo == 0)
path_shp_barcelona = here::here("1_data","3_data_Barris_Barcelona","barris_clean.shp")
barcelona_shape <- sf::st_read(path_shp_barcelona)
names(barcelona_rent)
barcelona_rent_gp = barcelona_shape %>% mutate(id_barri = as.numeric(BARRI)) %>% left_join(barcelona_rent %>% select(id_barri,price,square_mt,rooms) %>%
group_by(id_barri) %>% summarise_all(mean), by = c("id_barri")) %>% ungroup()
barcelona_rent_gp <- st_transform(barcelona_rent_gp, "+proj=longlat +datum=WGS84")
names(barcelona_rent_gp)
head(barcelona_rent_gp)
barcelona_rent_gp$price =  round(barcelona_rent_gp$price,1)
# Define the UI
ui <- fluidPage(
titlePanel("Precios Alquiler Barcelona"),
navbarPage(
"Barcelona Rent Prediction",
tabPanel("Map",
leafletOutput("map")),
tabPanel("Select Features",
selectInput("neighborhood", "Barrio:",
choices = unique(barcelona_rent_gp$NOM)),
sliderInput("bedrooms", "Número de habitaciones:",
min = 1, max = 10, value = 4),
checkboxInput("furnished", "Amueblado", value = FALSE),
sliderInput("bathrooms", "Número de baños:",
min = 1, max = 5, value = 2),
actionButton("predictButton", "Generar Predicción")
),
tabPanel("Results",
tableOutput("predictionTable")
)
)
)
# Define the server logic
server <- function(input, output) {
# Render the map
output$map <- renderLeaflet({
leaflet() %>%
addTiles() %>%
addPolygons(
data = barcelona_rent_gp,
fillColor = ~colorPalette()(price),
fillOpacity = 0.7,
color = "white",
weight = 1,
popup = ~paste0("<b>Barrio: </b>", NOM,
"<br><b>Precio medio: </b>", price, "€")
) %>%
addLegend(
position = "bottomright",
pal = colorPalette(),
values = barcelona_rent_gp$price,
title = "Precio medio alquiler (€)",
opacity = 1
)
})
# Define the color palette for the map polygons
colorPalette <- reactive({
colorNumeric(
palette = "Blues",
domain = barcelona_rent_gp$price
)
})
# Lógica para generar predicciones
observeEvent(input$predictButton, {
# Obtener los valores seleccionados por el usuario
selected_neighborhood <- input$neighborhood
selected_bedrooms <- input$bedrooms
selected_furnished <- input$furnished
selected_bathrooms <- input$bathrooms
# Realizar predicciones con los valores seleccionados
# Reemplaza esto con tu lógica de predicción real
predicted_price <- runif(1, 1000, 5000)  # Ejemplo: predicción aleatoria
# Crear una tabla de resultados
results_df <- data.frame(
Barrio = selected_neighborhood,
Habitaciones = selected_bedrooms,
Amueblado = ifelse(selected_furnished, "Sí", "No"),
Baños = selected_bathrooms,
Precio_Predicho = predicted_price
)
# Mostrar la tabla de resultados
output$predictionTable <- renderTable({
results_df
})
})
}
# Run the Shiny app
shinyApp(ui = ui, server = server)
